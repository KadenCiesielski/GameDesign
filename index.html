<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sphere Completion Game</title>
</head>
<body>
    <h1>Click the spheres to toggle their color and their neighbors</h1>
    <canvas id="myCanvas"></canvas>

    <script type="module">
    import * as THREE from 'three';

    // Global variables
    const clock = new THREE.Clock();
    const spherePool = []; // Object pool for spheres
    const grid = []; // 3x3 grid to track sphere positions
    const gridSize = 3; // 3x3 grid

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 0, 100);

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('myCanvas'), antialias: true });
    renderer.setClearColor(0x000000);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Light for better visuals
    const light = new THREE.PointLight(0xffffff, 1, 1000);
    light.position.set(50, 50, 50);
    scene.add(light);

    // Create a sphere with a default color
    function createSphere(x, y, index) {
        const geometry = new THREE.SphereGeometry(5, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White color initially
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(x, y, 0);
        sphere.userData = { index, color: 0xffffff }; // Store index and color
        return sphere;
    }

    // Initialize grid and object pool
    function initializeGrid() {
        const spacing = 20; // Distance between spheres
        let id = 0;

        for (let row = 0; row < gridSize; row++) {
            const gridRow = [];
            for (let col = 0; col < gridSize; col++) {
                const x = (col - 1) * spacing; // Centered around 0
                const y = (1 - row) * spacing; // Centered around 0
                const sphere = createSphere(x, y, id++);
                scene.add(sphere);
                spherePool.push(sphere);
                gridRow.push(sphere);
            }
            grid.push(gridRow);
        }
    }

    // Helper to get neighbors of a sphere
    function getNeighbors(row, col) {
        const neighbors = [];

        if (row > 0) neighbors.push(grid[row - 1][col]); // North
        if (row < gridSize - 1) neighbors.push(grid[row + 1][col]); // South
        if (col > 0) neighbors.push(grid[row][col - 1]); // West
        if (col < gridSize - 1) neighbors.push(grid[row][col + 1]); // East

        return neighbors;
    }

    // Toggle sphere color
    function toggleSphereColor(sphere) {
        const isRed = sphere.userData.color === 0xff0000; // Check if it's red
        sphere.material.color.set(isRed ? 0xffffff : 0xff0000); // Toggle color
        sphere.userData.color = isRed ? 0xffffff : 0xff0000;
    }

    // Handle sphere click
    function handleClick(sphere) {
        const sphereIndex = sphere.userData.index;
        const row = Math.floor(sphereIndex / gridSize);
        const col = sphereIndex % gridSize;

        // Toggle the clicked sphere
        toggleSphereColor(sphere);

        // Get and toggle neighbors
        const neighbors = getNeighbors(row, col);
        neighbors.forEach(toggleSphereColor);
    }

    // Raycaster for mouse clicks
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onDocumentMouseDown(event) {
        event.preventDefault();

        // Normalize mouse coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check intersections
        const intersects = raycaster.intersectObjects(spherePool);

        if (intersects.length > 0) {
            const clickedSphere = intersects[0].object;
            handleClick(clickedSphere);
        }
    }

    document.addEventListener('mousedown', onDocumentMouseDown, false);

    // Initialize the grid
    initializeGrid();

    // Animate
    function animate() {
        const delta = clock.getDelta(); // Delta time
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    animate();
    </script>
</body>
</html>